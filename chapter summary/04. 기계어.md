# 4.1 배경

## 4.1.1 기계
- 기계어는 **프로세서** 와 **레지스터** 들을 이용해서 **메모리**를 조작 할 수 있도록 미리 정의된 규칙 

```
1. 메모리 : 데이터와 명령어를 저장하는 하드웨어 장치
2. 프로세서 : 특정한 기초 연산들을 수행하는 장치
3. 레지스터 : 메모리 접근 연산이 상대적으로 느리기 때문에 프로세서 바로 옆에 위치해서 
             프로세서가 명령어와 데이터를 빠르게 조작할 수 있도록 로컬 고속 메모리 역할을 함
```

## 4.1.2 언어
- 기계어 프로그램은 명령어들을 코드화한 것
- 명령어를 이해하려면 해당 하드웨어 플랫폼의 명령 집합을 알아야함

```
[용어 정리]
- 연상 기호(mnemonic) : 기호가 의미하는 바를 알기 쉽도록 특별한 이름을 붙인 기호
- 어셈블리(assembly) : 기계 명령어
- 어셈블러(assembler) : 어셈블리를 2진 코드로 번역하는 프로그램
```

## 4.1.3 명령
- 산술 및 논리 연산
 ex) 기초 산술 연산, 기본적인 불 연산 (비트 반전, 비트 이동)
- 메모리 접근 명령
    1. 산술 및 논리 명령
    2. 로드와 저장 명령
- 주소 지정 모드
  1. 직접 주소 지정 방식 : 특정 주소를 직접 쓰거나, 나타내는 기호 활용 방식
  ```
  LOAD R1, 67 // R1<-Memory[67]
  ```
  2. 즉시 주소 지정 방식 : 주소를 값으로 취급하고 그 값을 레지스터에 로드하는 방식
  ```
  LAOD R1, 67 //R1<-67
  ```
  3. 간접 주소 지정 방식 : 필요한 주소 값을 저장하고 있는 메모리 위치를 참조하는 방식 (포인터)
  ```
  LOAD* R2,R1 //R2<-Memory[R1]
  ```
- 제어 흐름
  - 
  - 반복
  - 조건 실행
  - 서브루틴 호출
  
# 4.2 핵 기계어 명세
  
## 4.2.1 개요
  - 핵 컴퓨터 = 폰 노이만 플랫폼 
  - 구성 : CPU, 명령용 & 데이터용 메모리 모듈, 2개의 메모리 메핑 I/O 장치
  
  ![폰노이만 구조](https://upload.wikimedia.org/wikipedia/ko/a/a1/Von_Neumann_architecture_kor.png)
  
  - **메모리 주소 공간**
    - 명령어 메모리 (읽기 전용) => CD ROM
    - 데이터 메모리
  - **레지스터**
    - D 레지스터 : 데이터 값을 저장하는 용도
    - A 레지스터 : 맥락에 따라 데이터 값, 데이터 메모리의 주소나 명령어 메모리 주소
    ~~~
    D = Memory[516] - 1
    // A 레지스터에 516을 넣고, 그 다음에 D = M - 1 명령어를 실행해야 한다
    ~~~
  - **명령어 종류**
    - A-명령어 : 주소 명령어 (address instruction)
    - C-명령어 : 계산 명령어 (compute instruction)
    
## 4.2.2 A-명령어
  - A-명령어는 A 레지스터에 15비트 값을 설정하는 데 쓰인다
  - 용도
    1. 상수를 입력하는 용도
    2. 다음 C-명령어에서 해당 주소에 있는 값을 참조할 수 있도록 A 레지스터에 데이터의 주소를 미리 입력해 두는 용도다
    3. A레지스터에 점프할 주소를 미리 입력해서, 그 다음 점프 C-명령어를 준비하는 용도다
    ~~~
    A-명령어: @value //여기서 value는 음수가 아닌 10진수, 또는 그 숫자를 참조하는 기호다
                
    Binary: [ 0 v v v ] [ v v v v ] [ v v v v ] [ v v v v ]
    // v = 0 or 1
    ~~~
  
## 4.2.3 C-명령어
  - C-명령어는 핵 플랫폼에서 거의 모든 일을 수행하는 명령어
  - 역할
    1. 무엇을 계산하나?
    2. 계산된 값을 어디에 저장하나?
    3. 그 다음에 할 일은 무엇인가?
  ~~~
  C-명령어: dest=comp;jump //dest나 jump 필드는 공란일 수 있다
                         //dest가 공란이면 '='가 생략된다.
                         //jump가 공란이면 ';'가 생략된다.
                         
  Binary: [ 1 1 1 a ] [ c1 c2 c3 c4 ] [ c5 c6 d1 d2 ] [ d3 j1 j2 j3 ]
  // 맨 왼쪽 비트 값 1 은 이 명령어가 C-명령어 임을 나타냄
  // 그 다음 2비트는 사용되지 않는다
  // a ~ c6 = comp
  // d1 ~ d3 = dest 
  // j1 ~ j3 = jump
  ~~~
  - **계산 필드(Computation field)**
    - 핵 ALU는 D 와 A 및 M 레지스터 상에서 미리 정해진 함수들을 계산한다. 
    - comp 필드에 계산할 함수가 정의됨
  - **목적지 필드(Destination field)**
    - *1,2번째 d-비트*는 계산된 값을 각각 A 레지스터와 D 레지스터에 저장할지를 결정하는 코드
    - *3번째 d-비트*는 계산된 값을 M에 저장할지 결정
  - **점프 필드(Jump field)**
    - 컴퓨터가 다음에 수행할 일을 지시한다
    - 다음에 할일 2가지
      1. 프로그램에서 다음번 명령을 불러와서 실행하는 것 (기본 설정)
      2. 프로그램 내 다른 곳에 위치한 명령을 불러와서 실행
    - ALU 출력 값에 따라 점프 여부 결정
      1. ALU 출력값이 음수일때 : 1번째 j비트
      2. ALU 출력값이 0일때 : 2번째 j비트
      3. ALU 출력값이 양수일때 : 3번째 j비트
      
      ~~~
      //예제
      [논리]
      if Memory[3]=5 then goto 100
      else goto 200
      
      [구현]
      @3
      D=M     //D=Memory[3]
      @5
      D=D-A   //D=D-5
      @100
      D; JEQ  //If D=0 goto 100
      @200
      0; JMP  // Goto 200
      ~~~
  
